{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/middleware.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\n\r\nconst publicRoutes = [\"/\", \"/register\", \"/login\"];\r\n\r\nexport async function middleware(request) {\r\n  const { pathname } = request.nextUrl;\r\n\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  const accessToken = request.cookies.get(\"accessToken\")?.value;\r\n  const decodedToken = JSON.parse(atob(accessToken.split(\".\")[1]));\r\n  const user = GenerateSlug(decodedToken.name);\r\n  if (!accessToken) {\r\n    return NextResponse.redirect(new URL(\"/\", request.url));\r\n  }\r\n\r\n  try {\r\n    // Fetch vendor profile using the access token\r\n    const apiUrl = process.env.JOB_PORTAL_API_URL;\r\n    const response = await fetch(`${apiUrl}/api/v1/vendor/vendor-profile`, {\r\n      method: \"GET\",\r\n      headers: {\r\n        Authorization: `Bearer ${accessToken}`,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      cache: \"no-store\", // Avoid caching to fetch real-time data\r\n    });\r\n\r\n    // Handle failed profile fetch\r\n    if (!response.ok) {\r\n      console.error(`Failed to fetch vendor profile: ${response.status}`);\r\n      return NextResponse.redirect(new URL(\"/\", request.url));\r\n    }\r\n\r\n    // Parse vendor profile data\r\n    const { data: profileData } = await response.json();\r\n    const vendorName = GenerateSlug(profileData?.result?.data?.vendorName);\r\n\r\n    // Validate vendor name exists\r\n    if (!vendorName) {\r\n      console.warn(\"Vendor name not found in profile data\");\r\n      return NextResponse.redirect(new URL(\"/\", request.url));\r\n    }\r\n\r\n    // Validate vendor route access\r\n    const pathSegments = pathname.split(\"/\").filter(Boolean);\r\n    const firstSegment = pathSegments[0];\r\n\r\n    // Redirect to correct vendor-specific route if needed\r\n    if (firstSegment !== vendorName) {\r\n      const additionalPath = pathSegments.slice(1).join(\"/\");\r\n      const redirectUrl = additionalPath\r\n        ? `/${vendorName}/${additionalPath}`\r\n        : `/${vendorName}`;\r\n      return NextResponse.redirect(new URL(redirectUrl, request.url));\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error processing middleware:\", error);\r\n    return NextResponse.redirect(new URL(\"/\", request.url));\r\n  }\r\n\r\n  // Allow access to the requested route\r\n  return NextResponse.next();\r\n}\r\n\r\n// Configure middleware to run on all routes except specified ones\r\nexport const config = {\r\n  matcher: [\"/((?!api|_next/static|_next/image|favicon.ico|public).*)\"],\r\n};\r\n\r\n// import { NextResponse } from \"next/server\";\r\n\r\n// const onlyAuthNotExist = [\"/sign-in\", \"/sign-up\", \"/forgot-password\"];\r\n// const privateRoutes = [\"/blogs\", \"/settings\", \"/product\", \"/welcome\"];\r\n\r\n// export async function middleware(request) {\r\n//   // const dispatch = useDispatch();\r\n//   const { pathname } = request.nextUrl;\r\n//   const accessToken = request.cookies.get(\"accessToken\")?.value;\r\n//   // console.log(\"accessToken from  middleware...: \", accessToken);\r\n\r\n//   const isPrivateRoute = privateRoutes.some((route) =>\r\n//     pathname.startsWith(route)\r\n//   );\r\n\r\n//   const isAuthRestrictedRoute = onlyAuthNotExist.includes(pathname);\r\n\r\n//   if (isPrivateRoute && !accessToken) {\r\n//     return NextResponse.redirect(new URL(\"/\", request.url));\r\n//   }\r\n\r\n//   return NextResponse.next();\r\n// }\r\n\r\n// export const config = {\r\n//   matcher: [\"/((?!api|_next/static|_next/image|favicon.ico).*)\"],\r\n// };\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,MAAM,eAAe;IAAC;IAAK;IAAa;CAAS;AAE1C,eAAe,WAAW,OAAO;IACtC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,IAAI,aAAa,QAAQ,CAAC,WAAW;QACnC,OAAO,qLAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,MAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;IACxD,MAAM,eAAe,KAAK,KAAK,CAAC,KAAK,YAAY,KAAK,CAAC,IAAI,CAAC,EAAE;IAC9D,MAAM,OAAO,aAAa,aAAa,IAAI;IAC3C,IAAI,CAAC,aAAa;QAChB,OAAO,qLAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,IAAI;QACF,8CAA8C;QAC9C,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;QAC7C,MAAM,WAAW,MAAM,MAAM,GAAG,OAAO,6BAA6B,CAAC,EAAE;YACrE,QAAQ;YACR,SAAS;gBACP,eAAe,CAAC,OAAO,EAAE,aAAa;gBACtC,gBAAgB;YAClB;YACA,OAAO;QACT;QAEA,8BAA8B;QAC9B,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,QAAQ,KAAK,CAAC,CAAC,gCAAgC,EAAE,SAAS,MAAM,EAAE;YAClE,OAAO,qLAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;QACvD;QAEA,4BAA4B;QAC5B,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,SAAS,IAAI;QACjD,MAAM,aAAa,aAAa,aAAa,QAAQ,MAAM;QAE3D,8BAA8B;QAC9B,IAAI,CAAC,YAAY;YACf,QAAQ,IAAI,CAAC;YACb,OAAO,qLAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;QACvD;QAEA,+BAA+B;QAC/B,MAAM,eAAe,SAAS,KAAK,CAAC,KAAK,MAAM,CAAC;QAChD,MAAM,eAAe,YAAY,CAAC,EAAE;QAEpC,sDAAsD;QACtD,IAAI,iBAAiB,YAAY;YAC/B,MAAM,iBAAiB,aAAa,KAAK,CAAC,GAAG,IAAI,CAAC;YAClD,MAAM,cAAc,iBAChB,CAAC,CAAC,EAAE,WAAW,CAAC,EAAE,gBAAgB,GAClC,CAAC,CAAC,EAAE,YAAY;YACpB,OAAO,qLAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,aAAa,QAAQ,GAAG;QAC/D;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,qLAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,sCAAsC;IACtC,OAAO,qLAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAGO,MAAM,SAAS;IACpB,SAAS;QAAC;KAA2D;AACvE,GAEA,8CAA8C;CAE9C,yEAAyE;CACzE,yEAAyE;CAEzE,8CAA8C;CAC9C,uCAAuC;CACvC,0CAA0C;CAC1C,mEAAmE;CACnE,sEAAsE;CAEtE,yDAAyD;CACzD,iCAAiC;CACjC,OAAO;CAEP,uEAAuE;CAEvE,0CAA0C;CAC1C,+DAA+D;CAC/D,MAAM;CAEN,gCAAgC;CAChC,IAAI;CAEJ,0BAA0B;CAC1B,oEAAoE;CACpE,KAAK"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}